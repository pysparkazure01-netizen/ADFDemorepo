CREATE OR REPLACE PROCEDURE PROD_ADS.DWNSTRM_SALESFORCE.SALESFORCE_CONTACT_UPDATE(SALESFORCE_UPDATE_FROM_APP VARCHAR)
RETURNS STRING
LANGUAGE PYTHON
RUNTIME_VERSION = 3.8
HANDLER = 'main'
EXTERNAL_ACCESS_INTEGRATIONS = (SALESFORCE_API_EXTERNAL_ACCESS_INTEGRATION)
PACKAGES = ('requests','simplejson','snowflake-snowpark-python','pandas')
SECRETS = ('cred' = PROD_DB_MANAGER.SECRETS.SALESFORCE_API_INTEGRATION_SECRET)
EXECUTE AS OWNER
AS
$$
import time
import requests
import pandas as pd
from io import StringIO
import simplejson as json
import _snowflake
import snowflake.snowpark as snowpark

BULK_API_VERSION = "v60.0"

def _escape_sql(s):
    if s is None:
        return ''
    return str(s).replace("'", "''")

def _headers_json(token, subscription_id=None):
    h = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    if subscription_id:
        h["Ocp-Apim-Subscription-Key"] = subscription_id
    return h

def _headers_csv(token, subscription_id=None):
    h = {"Authorization": f"Bearer {token}", "Content-Type": "text/csv"}
    if subscription_id:
        h["Ocp-Apim-Subscription-Key"] = subscription_id
    return h

def create_bulk_job(instance_url, token, subscription_id):
    url = f"{instance_url}/services/data/{BULK_API_VERSION}/jobs/ingest"
    payload = {
        "object": "Contact",
        "operation": "update",
        "contentType": "CSV",
        "lineEnding": "LF"
    }
    resp = requests.post(url, headers=_headers_json(token, subscription_id), json=payload)
    resp.raise_for_status()
    return resp.json()["id"]

def upload_batch(instance_url, token, subscription_id, job_id, csv_data):
    url = f"{instance_url}/services/data/{BULK_API_VERSION}/jobs/ingest/{job_id}/batches"
    resp = requests.put(url, headers=_headers_csv(token, subscription_id), data=csv_data)
    resp.raise_for_status()

def close_job(instance_url, token, subscription_id, job_id):
    url = f"{instance_url}/services/data/{BULK_API_VERSION}/jobs/ingest/{job_id}"
    payload = {"state": "UploadComplete"}
    resp = requests.patch(url, headers=_headers_json(token, subscription_id), json=payload)
    resp.raise_for_status()

def wait_for_completion(instance_url, token, subscription_id, job_id, poll_sec=5):
    url = f"{instance_url}/services/data/{BULK_API_VERSION}/jobs/ingest/{job_id}"
    while True:
        resp = requests.get(url, headers=_headers_json(token, subscription_id))
        resp.raise_for_status()
        state = resp.json().get("state")
        if state in ("JobComplete", "Failed", "Aborted"):
            return state
        time.sleep(poll_sec)

def download_results_c
